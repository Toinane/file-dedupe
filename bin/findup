#!/usr/bin/env node
var opts = require('yargs')
    .options({
      'include': { },
    })
    .boolean('json')
    .boolean('list')
    .boolean('stdin')
    argv = opts.parse(process.argv);

var fs = require('fs'),
    path = require('path'),
    Dedupe = require('../index.js'),
    parallel = require('miniq'),
    bytes = require('bytes');

var dedupe = new Dedupe(),
    queue = parallel(12),
    progress = { total: 0, complete: 0 };

queue.maxStack = Infinity;

var start,
    width = 20,
    fmt = '[:bar] :current / :total :percent :etas';

function status() {
  var ratio = progress.complete / progress.total;
  ratio = Math.min(Math.max(ratio, 0), 1);

  var percent = ratio * 100,
      complete = Math.round(width * ratio),
      incomplete,
      elapsed = new Date() - start,
      eta = (percent == 100) ? 0 : elapsed * (progress.total / progress.complete - 1);

  complete = Array(complete).join('=');
  incomplete = Array(width - complete.length).join(' ');

  return fmt
          .replace(':bar', complete + incomplete)
          .replace(':current', progress.complete)
          .replace(':total', progress.total)
          .replace(':elapsed', isNaN(elapsed) ? '0.0' : (elapsed / 1000).toFixed(1))
          .replace(':eta', (isNaN(eta) || !isFinite(eta)) ? '0.0' : (eta / 1000).toFixed(1))
          .replace(':percent', percent.toFixed(0) + '%');
}

var prev = 0;

var tasks = [];

queue.once('err', function(err) {
  throw err;
});

function scanStatus() {
  process.stderr.clearLine();
  process.stderr.cursorTo(0);
  process.stderr.write('Found ' + tasks.length + ' files.');

}

// sync FS access is actually faster in cases where you don't need to perform
// parallel access - and globs are significantly slower, see https://github.com/isaacs/node-glob/issues/78
var count = 0;

function walk(path) {
  try {
    var stat = fs.statSync(path);
  } catch (e) {
    return;
  }
  if (stat.isDirectory()) {
    try {
      fs.readdirSync(path).forEach(function(entry) {
        walk(path + '/' + entry);
      });
    } catch(e) {
      return;
    }
  } else {
    tasks.push([path, stat]);
    if (tasks.length > prev + 100) {
      scanStatus();
      prev = tasks.length;
    }
  }
}

if(argv['version'] || argv['v'] ) {
  console.log(require('../package.json').version);
  process.exit();
}

if(!argv['include'] && !argv['stdin']) {
  return fs.createReadStream(__dirname + '/usage.md').pipe(process.stdout).on('close', function () { process.exit(1) });
}


// Try reading from stdin
if (argv.stdin) {
  var input = '';
  process.stdin.on('data', function(data) {
    input += data;
  });
  process.stdin.once('end', function() {
    tasks = input.split('\n').map(function(name) {
      return [ name, null ];
    });
    run();
  });
  process.stdin.resume();
} else {
  walk(argv.include);
  process.stderr.write('\n');
  // eliminate length-0
  prev = tasks.length;
  tasks = tasks.filter(function(item) { return !item[1] || item[1].size > 0; });
  console.error('Removed ' + (prev - tasks.length) + ' files with zero size from list.');
  run();
}

var statusInterval;

function printStatus() {
  if (!statusInterval) {
    return;
  }
  process.stderr.clearLine();
  process.stderr.cursorTo(0);
  process.stderr.write(status() + ' ' +
    (progress.complete - prev) + ' items / s' +
    ' read ' + bytes(dedupe.bytesRead) + ' bytes');

  prev = progress.complete;

  if (progress.complete == progress.total) {
    clearInterval(statusInterval);
    process.stderr.write('\n');
  }
}


function run() {
  prev = 0;

  statusInterval = setInterval(printStatus, 1000);

  progress.total = tasks.length;
  start = new Date();
  process.stderr.write(' ');
  process.stderr.clearLine();
  process.stderr.cursorTo(0);
  process.stderr.write(status());

  queue.once('empty', report);

  queue.exec(tasks.map(function(items) {
    return function(done) {
      var name = items[0];
      dedupe.find(name, items[1], function(err, result, stat) {
        if (result !== false) {
          if (!dups[result]) {
            dups[result] = [ path.normalize(name) ];
            sizes[result] = stat.size;
          } else {
            dups[result].push(path.normalize(name));
          }
        }

        progress.complete++;
        done();
      });
    };
  }));
}

var dups = {},
    sizes = {};


function report() {
  var clusters = [];

  printStatus();

  Object.keys(dups).forEach(function(key) {
    clusters.push([key].concat(dups[key]));
  });

  // sort by total size
  clusters.sort(function(a, b) {
    return (b.length * sizes[b[0]]) - (a.length * sizes[a[0]] );
  });

  if (argv.json) {
    clusters.forEach(function(cluster) {
      var size = sizes[cluster[0]];

      if (argv['omit-first']) {
        cluster = cluster.slice(1);
      }

      console.log(JSON.stringify({ files: cluster, size: size, total: cluster.length * size }));
    });
  } else if(argv.list) {
    clusters.forEach(function(cluster) {
      var size = sizes[cluster[0]];
      if (argv['omit-first']) {
        cluster = cluster.slice(1);
      }
      cluster.map(function(name) {
        console.log(name);
      });
      console.log();
    });
  } else {
    console.log();
    clusters.forEach(function(cluster, i) {
      var size = sizes[cluster[0]];
      console.log(cluster.length + ' files in cluster ' + i + ' (' + bytes(size) + ' bytes each, ' + bytes(cluster.length * size) + ' total)');
      cluster.map(function(name) {
        console.log(name);
      });
      console.log();
    });
  }
}
